"""Diplomacy overview widgets for the Survival Truck UI.

This local version of the diplomacy view enhances the original by
displaying the player's reputation with each faction. Reputation is
maintained in the :class:`~game.factions.FactionLedger` and indicates
how friendly or hostile a faction is towards the player. Positive
values are friendly, negative values are hostile, and zero is neutral.
"""

from __future__ import annotations

from collections.abc import Mapping
from dataclasses import dataclass

import networkx as nx
from rich.console import Group, RenderableType
from rich.panel import Panel
from rich.table import Table
from textual.widget import Widget

from ..factions import FactionRecord
from ..world.graph import allied_factions


@dataclass
class DiplomacySnapshot:
    """Lightweight container describing current diplomacy state."""

    factions: Mapping[str, FactionRecord]
    graph: nx.Graph | None


class DiplomacyView(Widget):
    """Render faction standings, alliances, player reputation and pending negotiations.

    In addition to displaying the relationship graph between NPC factions, this view
    surfaces the player's reputation with each faction and any outstanding
    negotiation proposals generated by the faction AI. Negotiations are
    proposals awaiting player response, such as truces, tribute demands or
    coalition invitations. They are presented in a simple table so the
    player can review them at a glance. This class does not handle
    accepting or rejecting proposals; that logic resides in the application.
    """

    def __init__(
        self,
        *,
        title: str = "Diplomacy",
        alliance_threshold: float = 15.0,
        border_style: str = "purple",
    ) -> None:
        super().__init__(id="diplomacy")
        self.title = title
        self.alliance_threshold = float(alliance_threshold)
        self.border_style = border_style
        self._snapshot = DiplomacySnapshot(factions={}, graph=None)
        # Track outstanding negotiations to display to the user. The list
        # contains mapping objects with at least keys: "faction", "type",
        # "demand", "reward" and "expires". See FactionAIController for
        # generation details.
        self._negotiations: list[Mapping[str, object]] = []
        # Track which factions are currently affected by world events.  This
        # set is used to highlight faction names in the UI.  Populated via
        # ``update_snapshot(event_flags=...)``.
        self._event_flags: set[str] = set()

    # ------------------------------------------------------------------
    def update_snapshot(
        self,
        factions: Mapping[str, FactionRecord],
        graph: nx.Graph | None,
        negotiations: Sequence[Mapping[str, object]] | None = None,
        event_flags: Mapping[str, object] | None = None,
    ) -> None:
        """Store the latest diplomacy state and refresh the widget.

        Parameters
        ----------
        factions:
            Current mapping of faction names to records.
        graph:
            NetworkX graph representing inter-faction standings and alliances.
        negotiations:
            Optional sequence of negotiation proposals generated by the faction AI. If
            provided, these will be displayed in a separate panel. Each entry
            should be a mapping with at least the keys ``faction``, ``type``,
            ``expires``, and either ``demand`` or ``reward``.
        """

        self._snapshot = DiplomacySnapshot(factions=dict(factions), graph=graph)
        if negotiations is not None:
            # Normalize to a list of dicts for later rendering.
            self._negotiations = [dict(item) for item in negotiations]
        else:
            # Clear existing negotiations if none are supplied.
            self._negotiations = []
        # Store event flags indicating which factions are currently affected by
        # world events.  Keys in this mapping correspond to faction names.
        if event_flags is not None and isinstance(event_flags, Mapping):
            # Normalise to a set of names for quick lookup.
            self._event_flags = {str(k) for k, v in event_flags.items() if v}
        else:
            self._event_flags = set()
        self.refresh()

    # ------------------------------------------------------------------
    def render(self) -> RenderableType:
        factions = self._snapshot.factions
        graph = self._snapshot.graph

        if not factions:
            return Panel(
                "No faction data available",
                title=self.title,
                border_style=self.border_style,
            )

        if graph is None or graph.number_of_nodes() == 0:
            return Panel(
                "Diplomacy records pending",
                title=self.title,
                border_style=self.border_style,
            )

        standings_table = Table.grid(padding=(0, 1), expand=True)
        standings_table.add_row(
            "[bold]Faction A[/bold]", "[bold]Faction B[/bold]", "[bold]Standing[/bold]"
        )

        edges = sorted(
            (
                faction_a,
                faction_b,
                float(data.get("weight", graph.graph.get("neutral_value", 0.0))),
            )
            for faction_a, faction_b, data in graph.edges(data=True)
        )

        if edges:
            for faction_a, faction_b, value in edges:
                standings_table.add_row(faction_a, faction_b, f"{value:+.1f}")
        else:
            neutral = float(graph.graph.get("neutral_value", 0.0))
            standings_table.add_row("(no records)", "", f"{neutral:+.1f}")

        alliances_table = Table.grid(padding=(0, 1), expand=True)
        alliances_table.add_row("[bold]Faction[/bold]", "[bold]Allies[/bold]")

        alliance_rows = 0
        for faction in sorted(graph.nodes):
            allies = sorted(allied_factions(graph, faction, threshold=self.alliance_threshold))
            if not allies:
                continue
            alliance_rows += 1
            alliances_table.add_row(faction, ", ".join(allies))

        if alliance_rows == 0:
            alliances_table.add_row("(none)", "")

        # Build a table for player reputation
        rep_table = Table.grid(padding=(0, 1), expand=True)
        rep_table.add_row(
            "[bold]Faction[/bold]",
            "[bold]Reputation[/bold]",
            "[bold]Ideology[/bold]",
        )
        for name, record in sorted(factions.items()):
            rep = getattr(record, "reputation", 0.0)
            ideology = getattr(record, "ideology", "neutral")
            display_name = name
            # Highlight factions affected by world events with a marker
            if name in getattr(self, "_event_flags", set()):
                display_name = f"[yellow]*[/yellow] {name}"
            rep_table.add_row(display_name, f"{rep:+.1f}", str(ideology).capitalize())

        # Build a table for any pending negotiation proposals. Each negotiation
        # lists the faction making the proposal, the type (truce, tribute, aid,
        # coalition), a net value (negative for demand, positive for reward)
        # and the day on which it expires. If no negotiations are pending the
        # table will show a placeholder row.
        neg_table = Table.grid(padding=(0, 1), expand=True)
        neg_table.add_row(
            "[bold]Faction[/bold]",
            "[bold]Type[/bold]",
            "[bold]Net[/bold]",
            "[bold]Expires[/bold]",
        )
        if self._negotiations:
            for n in self._negotiations:
                fac = str(n.get("faction", ""))
                typ = str(n.get("type", "")).capitalize()
                demand = float(n.get("demand", 0.0) or 0.0)
                reward = float(n.get("reward", 0.0) or 0.0)
                net = reward - demand
                net_str = f"{net:+.0f}" if net != 0 else "0"
                exp = int(n.get("expires", 0))
                neg_table.add_row(fac, typ, net_str, str(exp))
        else:
            neg_table.add_row("(none)", "", "", "")

        body = Group(
            Panel(standings_table, title="Standings", border_style=self.border_style),
            Panel(alliances_table, title="Alliances", border_style=self.border_style),
            Panel(rep_table, title="Reputation", border_style=self.border_style),
            Panel(neg_table, title="Negotiations", border_style=self.border_style),
        )

        return Panel(body, title=self.title, border_style=self.border_style)


__all__ = ["DiplomacySnapshot", "DiplomacyView"]